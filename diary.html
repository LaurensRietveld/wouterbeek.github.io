<html>
  <head>
    <title>Dear diary</title>
  </head>
  <body>
    <h1>Dear diary...</h1>
    <h3>2014/10/24</h3>
    <ul>
      <li>Reverse Polish Notation (RPN) / postfix notation</li>
      <ul>
        <li>Inverted: Burks, Warren, Wright (1954); Bauer, Dijkstra (1960s)</li>
        <li>No brackets iff fixed operator arities</li>
        <li>Not the reverse of Polish notation for non-commutative operators (e.g., <code>// 6 3</code> (Polish) is <code>6 3 //</code> (RPN).</li>
        <li>TODO: Shunting-yard algorithm</li>
      </ul>
      </li>Polish notation / prefix notation</li>
      <ul>
        <li>Inverted: Lukasiewicz (1920s)</li>
      </ul>
    </ul>
    <h3>Domain errors in SWI</h3>
    Why does <code>must_be/2</code> not throw <code>domain_error</code>s?
    Example:
    <pre>
      ?- must_be(nonneg, -1).
      ERROR: Type error: `nonneg' expected, found `-1' (an integer)
      ?- must_be(nonneg, aap).
      ERROR: Type error: `nonneg' expected, found `aap' (an atom)
    </pre>
    
    <h3>Add domain- and type-declarations</h3>
    Design principles:
    <ul>
      <li>Domain declarations should accopany type declarations.</li>
      <li>Domain, type, and being-ground specifications should be module-local.</li>
    </ul>
    <pre>
      :- module(
        typecheck,
        [
          must_be_in/2 % :Type
                       % @Term
        ]
      ).
      
      :- use_module(library(error)).
      
      %! type_import(+Imported, +Imported)
      
      :- dynamic(type_import/2).
      :- multifile(type_import/2).
      
      :- meta_predicate(must_be_in(0,@)).
      
      
            
      %! must_be_in(:Type, @Term) is det.
      % @throws domain_error
      % @throws instantiation_error
      % @throws type_error
      %
      % Module-specific facts:
      %   - `in_domain(+Type, @Term) is semidet.`
      %   - `in_type(+Type, @Term) is semidet.`
      %   - `is_ground_type(+Type) is semidet.
      %
      
      must_be_in(error:var, Term):- !,
        throw(error(uninstantiation_error(X), _)).
      must_be_in(_, Term):-
        var(Term), !,
        instantiation_error(Term).
      must_be_in(M:Type, Term):-
        M:is_ground_type(Type),
        \+ ground(Type), !,
        instantiation_error(Term).
      must_be_in(M:Type, Term):-
        catch(
          (   M:in_type(Type, Term)
          ->  true
          ;   type_error(Type, Term)
          ),
          _,
          true
        ),
        (   M:in_domain(Type, Term)
        ->  true
        ;   domain_error(Type, Term)
        ).
      
      
      error:in_domain(Type, Term):-
        error:has_type(Type, Term).
      
      
      error:in_type(Integer, Term):-
        memberchk(
          Integer,
          [between(_,_),negative_integer,nonneg,positive_integer]
        ), !,
        integer(Term).
      </pre>
    <h3>WebLife</h3>
    Stored in file refered to by <code>http://www.wouterbeek.com/weblife/rdfs/rdfs_class?arity=1</code>:
    <pre>
    :- rdf_prefix(rdfs, 'http://...').
    :- wl_prefix(semweb, 'http://www.swi-prolog.org/library/semweb/').
    rdfs_class(Class):-
      semweb:rdfs_subclass_of(Class, rdfs:'Class').
    </pre>
    Other code uses:
    <pre>
    :- rdf_prefix(rdfs, 'http://...').
    :- wl_prefix(wb_rdfs, 'http://www.wouterbeek.com/weblife/rdfs/').
    :- initialization(wb_rdfs:rdfs_class(rdfs:'Class')).
    </pre>
  </body>
</html>
